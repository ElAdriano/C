\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{ragged2e}
\usepackage{amsmath}
\usepackage[margin=1in]{geometry}
\usepackage{polski}
\begin{document}
\clearpage\setcounter{page}{1}\setlength{\parindent}{0in}
{\centering
\textbf{Specyfikacja Funkcjonalna}
\par}


\bigskip

\textbf{Rozdzia{\l} 1: Opis Ogólny}

\bigskip
\textbf{Podrozdzia{\l} 1.1: Nazwa programu.}

Nazwa programu : 'Arkanoid'.

\bigskip
\textbf{Podrozdzia{\l} 1.2: Poruszany problem.}

Program jest przykładem implementacji gry typu Arkanoid, której celem jest zniszczenie wszystkich bloków dostępnych na mapie za pomocą piłki, która jest sterowana za pomocą paletki.

\bigskip
\textbf{Podrozdzia{\l} 1.3: U\.zytkownik docelowy.}

Program jest kierowany do pasjonatów gier komputerowych, w szczególności z czasów początków rynku gier.

\bigskip
\textbf{Rozdzia{\l} 2: Opis Funkcjonalno\'sci}
\bigskip

\textbf{Podrozdzia{\l} 2.1: Jak korzysta\'c z programu?}

Do poprawnego funkcjonowania programu potrzebna jest działająca mysz komputerowa oraz opcjonalnie klawiatura.

\bigskip
\textbf{Podrozdzia{\l} 2.2: Uruchomienie programu.}

W celu uruchomienia programu nale\.zy wywołać plik wykonywalny Arkanoid.jar a następnie za pomocą myszy wybierać odpowiednie opcje z menu.

\bigskip
\textbf{Podrozdzia{\l} 2.3: Mo\.zliwo\'sci programu.}

\begin{enumerate}
    \item Sterowanie odbywa się z wykorzystaniem głównie myszy komputerowej z opcjonalnym użyciem klawiatury.

    \item Program pozwala wybrać jedną z 10 przygotowanych map gry, ale jednocześnie pliki zawierające dane map są w pełni edytowalne.

    \item Za pomocą klawisza klawiatury przebieg gry może zostać zatrzymany i wznowiony.

    \item W trakcie gry pojawiają się bonusy, których zebranie powoduje dynamiczną zmianę trudności gry poprzez zmianę parametrów gry.
\end{enumerate}

\bigskip
\textbf{Rozdzia{\l} 3: Format danych i struktura plików}

\bigskip
\textbf{Podrozdzia{\l} 3.1: Pojęcia i pola formularza}

paletka -- plansza na której umieszczane są `\.zywe' komórki podane w pliku przy wywo{\l}aniu.

list -- lista `\.zywych' punktów.

simulator -- struktura przechowująca dane do prowadzenia symulacji.

\bigskip
\textbf{Podrozdzia{\l} 3.1: Struktura pakietów}

\bigskip
pakiet ‘main’ :
\begin{itemize}
\item Ball.java
\item Brick.java
\item CollisionManager.java
\item GameScreenController.java
\item Main.java
\item MainMenuController.java
\item MapChooserController.java
\item Paddle.java
\end{itemize}

\bigskip
pakiet ‘main.Templates’ :
\begin{itemize}
\item GameScreen.fxml
\item MainMenu.fxml
\item MapChooser.fxml
\item arkanoid\_styles.css
\item grid1.fxml
\item grid2.fxml
\item grid3.fxml
\item grid4.fxml
\item grid5.fxml
\item grid6.fxml
\item grid7.fxml
\item grid8.fxml
\item grid9.fxml
\item gridX.fxml
\item grid1.png
\item grid2.png
\item grid3.png
\item grid4.png
\item grid5.png
\item grid6.png
\item grid7.png
\item grid8.png
\item grid9.png
\item gridX.png
\item frame.png
\end{itemize}


\bigskip
\textbf{Podrozdzia{\l} 3.2: Dane wej\'sciowe}

Program jako dane wejściowe przyjmuje pliki o rozszerzeniu .fxml, z których są ładowane odpowiednie sceny okna, plik arkanoid\_styles.css zawierające style do tych okien oraz zdjęcia typu .png, które są wyświetlane w odpowiednich miejscach w oknie.

\bigskip
\textbf{Podrozdzia{\l} 3.3: Funkcje wewnętrzne}
\bigskip

Klasy w programie:
\begin{itemize}
\item "Ball" - klasa zawierająca atrybuty i metody piłki
\item "Brick" - klasa zawierająca atrybuty i metody klocka
\item "Paddle" - klasa zawierająca atrybuty i metody paletki odbijającej piłkę
\item "Bonus" - klasa zawierająca atrybuty i metody bonusu
\item "MapChooserController" - klasa kontrolera ekranu wyboru mapy
\item "CollisionManager"- klasa odpowiedzialna za sprawdzanie kolizji i wyliczanie kąta po odbiciu się piłki od klocka
\item "GameScreenController" - klasa kontrolera ekranu gry
\item "MainMenuController" - klasa kontrolera menu głównego
\item "Main" - klasa zawierająca inicjację okna 
\end{itemize}
    
\bigskip
Metody klasy Ball:
\begin{itemize}

\item public Ball(Circle circle, double velocityX, double velocityY);
- konstruktor klasy przyjmujący jako parametry okrąg będący reprezentacją piłki w pliku *.fxml oraz składową poziomą i pionową prędkości.
    
\item public void setX(double x);\\
- ustawia nową współrzędną poziomą piłki
    
\item public void setY(double y);\\
- ustawia nową współrzędną pionową piłki
    
\item public double getX();\\
- metoda dostępowa, zwraca aktualną wartość współrzędnej poziomej piłki
    
\item public double getY();\\
- metoda dostępowa, zwraca aktualną wartość współrzędnej pionowej piłki
    
\item public double getRadius();\\
- metoda dostępowa, zwraca stałą wartość promienia piłki
    
\item public double getVelocityX();\\
- metoda dostępowa, zwraca aktualną wartość składowej poziomej prędkości piłki
    
\item public double getVelocityY();\\
- metoda dostępowa, zwraca aktualną wartość składowej pionowej prędkości piłki
    
\item public void setVelocityX(double value);\\
- ustawia nową wartość składowej poziomej prędkości
    
\item public void setVelocityY(double value);\\
- ustawia nową wartość składowej pionowej prędkości
    
\item public double getNextX();\\
- wylicza nową wartość współrzędnej poziomej piłki

\item public double getNextY();\\
- wylicza nową wartość współrzędnej pionowej piłki
    
\item public Circle getCircle();\\
- metoda dostępowa, zwraca okrąg, będący prywatnym atrybutem klasy ‘Ball’
    
\item public Circle getNextCircle();\\
- zwraca okrąg o nowych współrzędnych, służy on jedynie do wyliczenia kolizji piłki z klockiem
   
\item public void makeBounceFromVertical();\\
- zmienia zwrot składowej pionowej prędkości
    
\item public void makeBounceFromHorizontal();\\
- zmienia zwrot składowej poziomej predkości

\end{itemize}
\bigskip

\bigskip
Metody klasy Bonus:
\begin{itemize}

\item public Bonus(Type type, double x, double y, AnchorPane field);\\
- konstruktor klasy przyjmujący jako parametry typ bonusu, jego współrzędne na ekranie i kontener do którego jest przypisany
    
\item public Rectangle getRectangle();\\
- metoda dostępowa, zwraca prostokąt, w którym znajduje się bonus

\item public Bounds getBounds();\\
- metoda dostępowa, zwraca obiekt zawierające informacje o pozycji i wielkości bonusu na ekranie

\item public Type getType();\\
- metoda dostępowa, zwraca typ bonusu

public double getVelocityY();\\
- metoda dostępowa, zwraca długość składowej pionowej prędkości
    
\item public void setY(double y);\\
- ustawia nową współrzędną pionową bonusu
    
\item public double getX();\\
- metoda dostępowa, zwraca aktualną wartość współrzędnej poziomej bonusu
    
\item public double getY();\\
- metoda dostępowa, zwraca aktualną wartość współrzędnej pionowej bonusu
    
\item public double getNextY();\\
- wylicza nową wartość współrzędnej pionowej bonusu

\item public double getWidth();\\
- metoda dostępowa, zwraca szerokość bonusu na ekranie
    
\item public double getHeight();\\
- metoda dostępowa, zwraca wysokość bonusu na ekranie

\item public void removeFromFiedl(AnchorPane field);\\
- usuwa bonus z kontenera na ekranie

\end{itemize}
\bigskip


Metody klasy Brick:
\begin{itemize}
\item public Brick(Rectangle rectangle, int initalHealthPoints);\\
- konstruktor klasy przyjmujący jako parametr prostokąt będący reprezentacją klocka w pliku                	*.fxml oraz ilość odbić po których dany klocek zostanie zniszczony
    
\item public Rectangle getRectangle();\\
- metoda dostępowa, zwraca prostokąt będący odpowiednikiem klocka
    

\item public int getHealthPoints();\\
- metoda dostępowa, zwraca aktualną liczbę dozwolonych trafień piłki w klocek, po których nie   	zostanie on zniszczony
    
\item public void decreaseHealthPoints();\\
- zmniejsza liczbę dozwolonych trafień w klocek o 1
    
\item public void setVisible(boolean value);\\
- ustawia parametr odpowiadający za widoczność klocka w okienku aplikacji
    
\item public boolean isVisible();\\
- sprawdza czy zadany klocek znajduje się jeszcze na planszy i jest możliwy do zniszczenia
    
\item public double getX();\\
- metoda dostępowa, zwraca współrzędną poziomą zadanego klocka
    
\item public double getY();\\
- metoda dostępowa, zwraca współrzędną pionową zadanego klocka

\item public double getWidth();\\
- metoda dostępowa, zwraca szerokość zadanego klocka
    
\item public double getHeight();\\
-metoda dostępowa, zwraca wysokość zadanego klocka
\end{itemize}

\bigskip
Metody klasy ‘CollisionManager’:
\begin{itemize}
\item public CollisionManager(Ball ball, Paddle paddle, AnchorPane field);\\
- konstruktor klasy przyjmujący jako parametry obiekt klasy ‘Ball’, ‘Paddle’ oraz ‘AnchorPane’. Parametry odpowiadają za monitorowaną piłkę, paletkę oraz okienko gry.

\item public void checkForCollisions(List \textless Brick\textgreater bricks);\\
- sprawdza czy w następnym położeniu piłki nastąpi zderzenie z klockami z listy

\item public boolean manageCollision(Rectangle rect, Circle circle);\\
- zwraca wartość true jeśli nastąpiła kolizja, w przeciwnym wypadku zwraca false
    
\item private void makeCornerBounce(Rectangle rect, Circle circle);\\
- zarządza zmianą składowych prędkości po odbiciu od rogu prostokąta
    
\item private void calculateCornerBounce(double cornerX, double cornerY);\\
- wylicza kąt i ustawia nowe wartości składowych prędkości piłki przy odbiciu od kąta
    
\item private CollisionType checkRectangleCircleIntersection(Rectangle rect, Circle circle);\\
- zwraca typ kolizji pomiędzy kołem i prostokątem
    
\item private boolean willBallCollideWithWall();\\
- sprawdza czy piłka zderzyła się z pionową ścianą

\item private boolean willBallCollideWithTop();\\
- sprawdza czy piłka zderzyła się z górną ścianą
\end{itemize}
\bigskip

Metody klasy ‘GameScreenController’:
\begin{itemize}
\item public void handleSceneClick();\\
- metoda zarządza rozpoczęciem gry, oczekując na kliknięcie myszy
    
\item private void Loop();\\
- zarządza zachowanie gry, z zależności od jej stanu
    
\item private GameState getGameState();\\
- zwraca aktualny stan gry

\item public void initialize(URL url, ResourceBundle rb);\\
- inicjuje mechanizmy działania aplikacji

Metody klasy ‘MapChooserController’:

\item private void handlePlayButton(ActionEvent event);\\
- ustawia wybraną planszę na ekran i umożliwia rozpoczęcie rozgrywki

\item private void handleMapButtons(ActionEvent event);\\
- przechwytuje odpowiedni wzór planszy i oznacza ją jako wybraną

\item public void initialize(URL url, ResourceBundle rb);\\
- ustawia wybraną planszę
\end{itemize}
\bigskip 

Metody klasy ‘Paddle’ :
\begin{itemize}
\item public Paddle(Rectangle rectangle);\\
- konstruktor klasy przyjmujący jako parametr obiekt klasy Rectangle
    
\item public Rectangle getRectangle();\\
- metoda dostępowa, zwraca obiekt klasy Rectangle
    
\item public double getX();\\
- metoda dostępowa, zwraca współrzędną poziomą obiektu

\item public double getY();\\
- metoda dostępowa, zwraca współrzędną pionową obiektu

\item public void setX(double x);\\
- zmienia wartość współrzędnej poziomej na wartość przyjętą jako parametr


\item public double getWidth();\\
- metoda dostępowa, zwraca szerokość obiektu

\item public double getHeight();\\
- metoda dostępowa, zwraca wysokość obiektu
\end{itemize}

\bigskip
\textbf{Rozdzia{\l} 4: Scenariusz pracy z programem}

1) Uruchomienie programu

Aby uruchomić program należy wywołać go w systemie operacyjnym zawierającym oprogramowanie Java.
\bigskip

2) Menu Główne

Użytkownik w menu głównym może wybrać opcję "PLAY", która przenosi go do menu wyboru mapy lub "EXIT", która spowoduje wyłączenie programu.
\bigskip

3) Menu Wyboru Mapy

W tym menu użytkownik może zaznaczyć wedle upodobań mapę, na której chciałby zagrać, a następnie potwierdzić wybór przyciskiem "Play".
\bigskip

4) Ekran Gry

Na ekranie gry znajdują się następujące elementy:
\begin{itemize}
\item górny pasek, który zawiera informacje na temat pozostałych żyć oraz czas od rozpoczęcia gry,
\item kolorowe prostokątne bloki, których zniszczenie jest celem użytkownika, w zależności od ilości uderzeń potrzebnych do zniszczenia przyjmują inny kolor,
\item piłka, której kolizja z blokiem powoduje zmniejszenie liczby uderzeń potrzebnych do zniszczenia bloui,
\item paletka, której pozycja jest ustawiana na podstawie pozycji kursora, służy do odbijania piłki w wybranym kierunku i zapobiegania opuszczenia boiska przez piłkę oraz zbierania bonusów,
\item bonusy, które losowo pojawiają się po zniszczeniu bloku, powodują zmianę parametrów gry: wielkość paletki, ilość piłek, wielkość piłki, prędkość piłki.
\end{itemize}

Na początku gry piłka jest zaczepiona do paletki. Kliknięcie lewym przyciskiem myszy na okno powoduje wystrzelenie piłki pod losowym kątem. Od tego momentu następuje odliczanie czasu gry i kliknięcie klawisza "P" na klawiaturze powoduje zatrzymanie gry. 
Piłka przemieszcza się ze stałą prędkością, odbijając się od ścan bocznych i sufitu oraz bloków, co powoduje ich zniszczenie lub zmniejszenie liczby uderzeń pozostałych do zniszczenia.
Przy zniszczeniu bloku istnieje 10\% szansy na pojawienie się losowego typu bonusu, które opadają i mogą zostać zebrane za pomocą paletki. Typy bonusów to: zwiększenie/zmniejszenie piłki, zwiększenie/zmniejszenie paletki, zwiększenie/zmniejszenie prędkości piłki, pojawienie się dodatkowych dwóch piłek z każdej istniejącej.

Zadaniem użytkownika jest zniszczenie wszystkich obecnych bloków, co powoduje wygraną i przeniesienie do Menu Głównego. W trakcie gry użytkownik posiada określoną liczbę żyć, która wynosi 3 na początku gry. Jeśli wszyskie piłki opuszczą boisko poprzez dolną ścianę okna użytkownik traci jedno z żyć i pojawia się nowa piłka przyczepiona do paletki, którą użytkownik może ponownie wystrzelić. Jeśli liczba żyć  osiągnie 0 użytkownik przegrywa grę i jest przenoszony do Menu Głównego.




\bigskip
\end{document}